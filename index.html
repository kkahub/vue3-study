<!DOCTYPE html>
<html lang="ko">
    <head>
        <mata charset="utf-8">
        <title>Vue3 Note</title>
        <style>
            *{
                margin:0; padding:0; font-family: '맑은고딕', 'Lato', Gothic A1, Consolas; font-size: 16px; line-height: 1.4;
            }
            body{background: #efefef; padding-bottom:10px;}
            h2{ margin:25px 10px 7px 10px; padding:2px 0; font-size:20px;}
            details{ overflow: hidden; margin:10px; box-shadow: 0 0 8px rgba(0,0,0,.2); border-radius: 7px; background:#fff;}
            summary {padding:12px 10px; font-size:18px; font-weight: bold; }
            .desc_wrap{ padding:7px 10px 7px 25px; border-top:1px solid #ddd;}
            ul{ list-style: none; }
            ul > li{ position: relative;  padding: 2px 0; padding-left:10px;}
            ul > li::before { content:'ㆍ'; position: absolute; top:3px; left:-4px;}
            p{padding:2px 5px;}
            b{font-weight: 700;}
            .code{overflow-x: auto; margin: 8px 0 15px; padding:10px; border-radius: 7px; background:#213547; color:#ddd;}
            xmp{display: inline-block;}
            ul > li > pre {margin: 8px 0 15px;}
            .gray{color:#888;}
            .org{color:#F07178;}
            .pp{color:#C792EA;}
        </style>
    </head>
    <body>
        <h2>반응형 기초</h2>
        <details>
            <summary>nextTick</summary>
            <div class="desc_wrap">
                <ul>
                    <li>
                        method에서 업데이트 된 DOM에 접근 가능하게 함
                        <div class="code">
                            <xmp>const onHandleEvent = () => {
    count.value += 1
    nextTick(() => {
        console.log(document.querySelector('#countPrint').textContent)
    })
}</xmp>
                        </div>
                    </li>
                    <li>
                        async / awaite로 nextTick 적용하는 방법
                        <div class="code">
                            <xmp>const onHandleEvent = async () => {
    count.value += 1
    await nextTick()
    console.log(document.querySelector('#countPrint').textContent) <span class="gray">// 2</span>
}</xmp>
                        </div>
                    </li>
                </ul>
            </div>
        </details>

        <h2>계산된 속성</h2>
        <details>
            <summary>method와 computed 차이</summary>
            <div class="desc_wrap">
                <ul>
                    <li>
                        <b>method</b> : 어떤 값이 변하면 리렌더링하고, 리렌더링 할 때 마다 함수를 실행함
                    </li>
                    <li>
                        <b>computed</b> : 관련된 값이 직접적으로 변화하기 전 까지 업뎃 안됨.
                        의존된 반응형을 기반으로 캐시 됨
                    </li>
                    <li>
                        computed는 기본이 getter 전용임. 드물게 수정 가능하게 하려면 get() / set()으로 설정해 줄 수 있음
                    </li>
                </ul>
            </div>
        </details>

        <h2>클래스와 스타일 바인딩</h2>
        <details>
            <summary>컴포넌트에서 클래스 사용. $attrs</summary>
            <div class="desc_wrap">
                <ul>
                    <li>
                        컴포넌트에서 준 클래스는 자식에게 추가로 준다.
                    </li>
                    <li>
                        클래스 바인딩도 마찬가지
                        <div class="code">
                            <xmp><MyComponent :class="{ active: isActive }" /></xmp>
                        </div>
                    </li>
                    <li>
                        여러 자식 엘리먼트 중에 클래스를 줄 자식에게 $attrs 속성을 사용해야함
                        <div class="code">
                            <xmp><p :class="$attrs.class">안녕!</p></xmp>
                        </div>
                    </li>
                </ul>
            </div>
        </details>

        <h2>조건부 렌더링</h2>
        <details>
            <summary>v-if와 v-show 차이</summary>
            <div class="desc_wrap">
                <ul>
                    <li>
                        v-if는 lazy함. 실제 조건부 렌더링으로 false면 true일 때 까지 아무 일도 안함.<br>
                        v-if는 전환 비용이 높음 → 조건이 적게 변경되는 경우 사용
                    </li>
                    <li>
                        v-show는 CSS기반으로 초기 조건과 관계 없이 렌더링<br>
                        v-show는 초기 렌더링 비용이 높음 → 매우 자주 변환 시 사용
                    </li>
                </ul>
            </div>
        </details>
        <details>
            <summary>v-if와 v-for 동시 사용</summary>
            <div class="desc_wrap">
                <ul>
                    <li>v-if와 v-for를 같은 노드에 사용불가</li>
                    <li>v-if가 우선순위가 높고, v-for 접근을 안함</li>
                    <li>
                        해결 : v-if / v-for 모두 <xmp><template></xmp>에 사용할 수 있기 때문에 템플릿에 v-for를 먼저 선언
                        <div class="code"><xmp><template v-for="todo in todos">
    <li v-if="!todo.isComplete">
        {{ todo.name }}
    </li>
</template></xmp></div>
                    </li>
                </ul>
            </div>
        </details>

        <h2>목록 렌더링</h2>
        <details>
            <summary>v-for</summary>
            <div class="desc_wrap">
                <ul>
                    <li>목록이 변경 될 때 추적할 수 있게 :key로 힌트를 제공해야함</li>
                    <li>컴포넌트에서 v-for를 사용하면 데이터를 전달하기 위해 props를 사용해야함</li>
                    <li>
                        computed로 편집한 객체나 배열을 v-for할 수도 있음
                        <div class="code">
                            <xmp>const fruitSort = computed(() => {
    return fruits.value.filter((fruit) => fruit.title === '포도')
})</xmp>
                        </div>
                    </li>
                </ul>
            </div>
        </details>
        <details>
            <summary>v-for와 ref/reactive</summary>
            <div class="desc_wrap">
                <ul>
                    <li>
                        ref 객체를 이용한 렌더링
                        <div class="code">
                            <xmp>const fruits = ref([{ title: '사과', color: '빨강' }, { title: '포도', color: '보라' }, { title: '오렌지', color: '주황' }])

<li v-for="(fruit, index) in fruits" :key="index">{{ fruit.title }} : {{ fruit.color }}</li></xmp>
                        </div>
                    </li>
                    <li>
                        reactive 객체를 이용한 렌더링
                        <div class="code">
                            <xmp>const fruits = reactive({ title: '사과', color: '빨강' })

<li v-for="(value, key, index) in fruits" :key="key">{{ index }}. {{ value }}</li></xmp>
                        </div>
                    </li>
                    <li>
                        - ref .접근자로 접근하지만 reactive는 알아서 접근<br>
                        - 객체를 재할당하면 ref는 반응형을 유지 / reactive는 반응형을 잃음<br>
                        - ref와 reactive를 섞어 쓰기보다는 ref로 통일하여 일관성 있게 작업
                    </li>
                </ul>
            </div>
        </details>

        <h2>이벤트 처리</h2>
        <details>
            <summary>이벤트 수식어</summary>
            <div class="desc_wrap">
                <ul>
                    <li>.stop : 클릭 이벤트 전파 중지( = event.stopPropagation())</li>
                    <li>.prevent : 기본 이벤트 중지( = event.preventDefault())</li>
                    <li>.self : event.target이 엘리먼트 자신일 경우만 실행</li>
                    <li>.capture : 캡처링</li>
                    <li>.once : 이벤트 한번만</li>
                    <li>.passive : event.preventDefault() 무효화.<br>.prevent와 동시 사용 불가</li>
                    <li>
                        수식어를 연결할 수도 있고, 핸들러 없이도 사용 가능
                        <div class="code">
                            <xmp><a @click.stop.prevent="doThat"></a>

<form @submit.prevent></form>

<div @scroll.passive="onScroll">...</div></xmp>
                        </div>
                    </li>
                </ul>
                <p>* @click.prevent.self :  모든 클릭 차단</p>
                <p>* @click.self.prevent :  자신 클릭 차단</p>
            </div>
        </details>

        <h2>Form 입력 바인딩</h2>
        <details>
            <summary>select</summary>
            <div class="desc_wrap">
                <ul>
                    <li>
                        v-model의 초기값=옵션값이 아니면 선택되지 않은 상태로 렌더링 됨<br>
                        iOS에서 첫 번째 항목을 선택 할 수 없게 됨<br>
                        빈값을 주고 비활성화 해야함
                    </li>
                </ul>
            </div>
        </details>

        <h2>감시자</h2>
        <details>
            <summary>watch 특성</summary>
            <div class="desc_wrap">
                <ul>
                    <li>얕은 감시자 특성 → 깊은 감시자로 변경하려면 deep:true</li>
                    <li>lazy 특성 → 즉각 감시로 변경하려면 immediate:true</li>
                    <li>
                        부모컴포넌트 업데이트 후 자신 컴포넌트 업데이트 전에 호출<br>
                        → 업데이트 후 DOM 액세스하려면 flush:'post'<br>
                        → 동일한 틱 내에 변경 때 마다 동기적으로 호출하려면 flush: 'sync'
                    </li>
                </ul>
            </div>
        </details>
        <details>
            <summary>watch와 computed의 역할</summary>
            <div class="desc_wrap">
                <ul>
                    <li>
                        computed는<br>
                        - 컴포넌트의 상태를 변경하고 싶을 때 사용
                    </li>
                    <li>
                        watch는<br>
                        - 비동기 처리 (ex : 데이터를 fetch할 때)<br>
                        - 시간이 많이 소요되는 조작 (ex : lodash)<br>
                        - DOM 조작하기<br>
                        - 로컬 저장소, 오디오 재생과 같은 브라우저 API<br>
                    </li>
                    <p>* computed가 선언형 프로그래밍 방식으로 사용 할 수 있으면 우선 시 한다.</p>
                </ul>
            </div>
        </details>
        <details>
            <summary>watch와 watchEffect 차이</summary>
            <div class="desc_wrap">
                <ul>
                    <li>
                        watch는<br>
                        - 이전 값을 같이 보고 싶을 때 사용<br>
                        - lazy해서 특정 데이터가 변경 됐을 때 실행<br>
                        - reactive 종속성이 변경 될 때만 실행
                    </li>
                    <li>
                        watchEffect는<br>
                        - watch의 단순화 버전<br>
                        - 의존성이 있는 데이터에 대해 즉각 실행(초기값 포함)<br>
                        - 정의되거나 reactive 종속성이 변경될 때 즉시 실행
                    </li>
                </ul>
            </div>
        </details>

        <h2>템플릿 참조</h2>
        <details>
            <summary>부모 , 자식간의 ref 활용을 위한 defineExpose</summary>
            <div class="desc_wrap">
                <ul>
                    <li>
                        script setup은 private하기 때문에 전체 액세스 권한을 거부할 수 있다.<br>
                        때문에 부모, 자식간에 같은 권한을 가지려면 defineExpose에 넣어 데이터를 노출한다.
                    </li>
                </ul>
            </div>
        </details>
    </body>
</html>